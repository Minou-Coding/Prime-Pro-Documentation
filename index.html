const { Events, MessageFlags, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, StringSelectMenuBuilder, StringSelectMenuOptionBuilder, ModalBuilder, TextInputBuilder, TextInputStyle, PermissionsBitField, PermissionFlagsBits, ChannelType } = require('discord.js');
const fs = require('fs');
const path = require('path');
const configManager = require('../utils/configManager');

module.exports = {
    name: Events.InteractionCreate,
    async execute(interaction) {
        if (!interaction.guild) return; // Ignore DMs

        try {
            // Re-load config for every interaction to ensure we have the latest data
            const config = configManager.getAll(interaction.guild.id);

            // --- CHAT INPUT COMMANDS ---
            if (interaction.isChatInputCommand()) {
                const command = interaction.client.commands.get(interaction.commandName);
                if (!command) return;

                try {
                    await command.execute(interaction);
                } catch (error) {
                    console.error(error);
                    if (interaction.replied || interaction.deferred) {
                        await interaction.followUp({ content: 'Une erreur est survenue lors de l\'ex√©cution de cette commande!', ephemeral: true });
                    } else {
                        await interaction.reply({ content: 'Une erreur est survenue lors de l\'ex√©cution de cette commande!', ephemeral: true });
                    }
                }
            }

            // --- BUTTONS ---
            else if (interaction.isButton()) {
                // === VERIFICATION ===
                if (interaction.customId === 'verify_user') {
                    const cfg = config.verification || {};
                    const unverifiedRoleId = cfg.unverifiedRole;
                    const verifiedRoleId = cfg.verifiedRole;

                    if (!verifiedRoleId) {
                        return interaction.reply({ content: '‚ùå Le syst√®me de v√©rification n\'est pas encore configur√© (R√¥le V√©rifi√© manquant).', flags: MessageFlags.Ephemeral });
                    }

                    const member = interaction.member;

                    try {
                        if (member.roles.cache.has(verifiedRoleId)) {
                            return interaction.reply({ content: '‚úÖ Vous √™tes d√©j√† v√©rifi√© !', flags: MessageFlags.Ephemeral });
                        }

                        if (unverifiedRoleId && member.roles.cache.has(unverifiedRoleId)) {
                            await member.roles.remove(unverifiedRoleId);
                        }

                        await member.roles.add(verifiedRoleId);

                        return interaction.reply({ content: 'üéâ V√©rification r√©ussie ! Vous avez maintenant acc√®s au serveur.', flags: MessageFlags.Ephemeral });

                    } catch (error) {
                        console.error("Verification error:", error);
                        return interaction.reply({ content: '‚ùå Une erreur est survenue lors de la v√©rification. Veuillez contacter un administrateur.', flags: MessageFlags.Ephemeral });
                    }
                }

                // === ROLES ===
                // Check if it's a role button
                let roleBtnData = null;
                if (config.roles && config.roles.buttons) {
                    roleBtnData = config.roles.buttons.find(b => b.customId === interaction.customId);
                }

                if (roleBtnData) {
                    const cfg = config.roles;
                    if (cfg.requiredRoleId && !interaction.member.roles.cache.has(cfg.requiredRoleId)) {
                        return interaction.reply({
                            content: `‚ùå Vous devez avoir le r√¥le <@&${cfg.requiredRoleId}> pour utiliser ces boutons.`,
                            flags: MessageFlags.Ephemeral
                        });
                    }

                    const roleId = roleBtnData.roleId;
                    const hasRole = interaction.member.roles.cache.has(roleId);
                    const action = hasRole ? "Retirer" : "Ajouter";

                    const confirmEmbed = new EmbedBuilder()
                        .setColor(hasRole ? 0xff0000 : 0x00ff00)
                        .setTitle(`Confirmation : ${action} le r√¥le`)
                        .setDescription(roleBtnData.message || `Voulez-vous ${action.toLowerCase()} ce r√¥le ?`);

                    const row = new ActionRowBuilder().addComponents(
                        new ButtonBuilder()
                            .setCustomId(`confirm_${roleId}_${hasRole ? 'remove' : 'add'}`)
                            .setLabel('Valider')
                            .setStyle(ButtonStyle.Success),
                        new ButtonBuilder()
                            .setCustomId('cancel_action')
                            .setLabel('Annuler')
                            .setStyle(ButtonStyle.Secondary)
                    );

                    await interaction.reply({ embeds: [confirmEmbed], components: [row], flags: MessageFlags.Ephemeral });
                }
                else if (interaction.customId.startsWith('confirm_')) {
                    const parts = interaction.customId.split('_');
                    const roleId = parts[1];
                    const action = parts[2]; // 'add' or 'remove'

                    try {
                        if (action === 'add') {
                            await interaction.member.roles.add(roleId);
                            await interaction.update({ content: '‚úÖ R√¥le ajout√© avec succ√®s !', embeds: [], components: [] });
                        } else {
                            await interaction.member.roles.remove(roleId);
                            await interaction.update({ content: 'üóëÔ∏è R√¥le retir√© avec succ√®s !', embeds: [], components: [] });
                        }
                    } catch (error) {
                        console.error(error);
                        await interaction.update({ content: '‚ùå Erreur de permission (Je ne peux pas g√©rer ce r√¥le).', embeds: [], components: [] });
                    }
                }
                else if (interaction.customId === 'cancel_action') {
                    await interaction.update({ content: 'Action annul√©e.', embeds: [], components: [] });
                }

                // === ASSISTANCE ===
                else if (interaction.customId === 'close_ticket') {
                    const cfg = config.assistance || {};
                    const isSupport = cfg.supportRoles && cfg.supportRoles.some(roleId => interaction.member.roles.cache.has(roleId));
                    const isAdmin = interaction.member.permissions.has(PermissionFlagsBits.Administrator);

                    if (!isSupport && !isAdmin) {
                        return interaction.reply({ content: '‚ùå Seul le support est autoris√© √† fermer les tickets.', ephemeral: true });
                    }

                    const modal = new ModalBuilder()
                        .setCustomId('close_reason_modal')
                        .setTitle('Fermeture du Ticket');

                    const reasonInput = new TextInputBuilder()
                        .setCustomId('close_reason')
                        .setLabel("Raison de la fermeture")
                        .setStyle(TextInputStyle.Paragraph)
                        .setRequired(true);

                    const firstActionRow = new ActionRowBuilder().addComponents(reasonInput);
                    modal.addComponents(firstActionRow);

                    await interaction.showModal(modal);
                }
                else if (interaction.customId === 'claim_ticket') {
                    try {
                        if (!interaction.channel.permissionsFor(interaction.guild.members.me).has([PermissionsBitField.Flags.ManageChannels, PermissionsBitField.Flags.ManageRoles])) {
                            return interaction.reply({ content: '‚ùå Je n\'ai pas la permission de g√©rer ce salon (ManageChannels + ManageRoles) pour modifier les permissions.', ephemeral: true });
                        }

                        await interaction.reply({ content: `üëÆ‚Äç‚ôÇÔ∏è Le ticket a √©t√© pris en charge par ${interaction.user}.` });

                        await interaction.channel.permissionOverwrites.edit(interaction.user.id, {
                            SendMessages: true,
                            AttachFiles: true
                        });

                        const currentTopic = interaction.channel.topic || "";
                        if (!currentTopic.includes("ClaimedBy:")) {
                            await interaction.channel.setTopic(`${currentTopic} | ClaimedBy: ${interaction.user.tag} (${interaction.user.id})`);
                        }

                        await interaction.channel.setName(`claimed-${interaction.user.username}`).catch(() => { });
                    } catch (error) {
                        console.error("Claim error:", error);
                        if (!interaction.replied) {
                            await interaction.reply({ content: '‚ùå Erreur lors de la prise en charge (Permissions ?)', ephemeral: true });
                        }
                    }
                }

                // --- UNHANDLED BUTTONS ---
                else {
                    if (!interaction.replied && !interaction.deferred) {
                        await interaction.reply({ content: '‚ö†Ô∏è Interaction inconnue.', ephemeral: true });
                    }
                }
            }

            // --- SELECT MENUS ---
            else if (interaction.isStringSelectMenu()) {
                // === ASSISTANCE ===
                if (interaction.customId === 'ticket_panel_select') {
                    const ticketType = interaction.values[0];

                    const modal = new ModalBuilder()
                        .setCustomId(`ticket_modal_${ticketType}`)
                        .setTitle('D√©tails de la demande');

                    const detailsInput = new TextInputBuilder()
                        .setCustomId('ticket_details')
                        .setLabel("Description d√©taill√©e")
                        .setStyle(TextInputStyle.Paragraph)
                        .setPlaceholder("Expliquez votre probl√®me en d√©tail ici...")
                        .setRequired(true);

                    const firstActionRow = new ActionRowBuilder().addComponents(detailsInput);
                    modal.addComponents(firstActionRow);

                    await interaction.showModal(modal);
                }
            }

            // --- MODALS ---
            else if (interaction.isModalSubmit()) {
                if (interaction.customId.startsWith('ticket_modal_')) {
                    // === ASSISTANCE: TICKET CREATION ===
                    const cfg = config.assistance || {};
                    const ticketType = interaction.customId.replace('ticket_modal_', '');

                    // Determine target category
                    let targetCategoryId = cfg.ticketCategory;
                    if (cfg.categoryMapping && cfg.categoryMapping[ticketType]) {
                        targetCategoryId = cfg.categoryMapping[ticketType];
                    }

                    if (!targetCategoryId) {
                        return interaction.reply({ content: '‚ùå La cat√©gorie des tickets n\'est pas configur√©e.', ephemeral: true });
                    }
                    const description = interaction.fields.getTextInputValue('ticket_details');
                    const guild = interaction.guild;

                    const maxTickets = cfg.maxTickets || 1;
                    const existingTickets = guild.channels.cache.filter(c =>
                        c.name.startsWith('ticket-') &&
                        c.topic &&
                        c.topic.includes(`(${interaction.user.id})`)
                    );

                    if (existingTickets.size >= maxTickets) {
                        return interaction.reply({ content: `‚ùå Vous avez atteint la limite de **${maxTickets}** ticket(s) ouvert(s). Veuillez fermer un ticket existant avant d'en ouvrir un nouveau.`, ephemeral: true });
                    }

                    const nameMapping = {
                        'assistance': 'assistance',
                        'report': 'signaler-une-personne',
                        'other': 'autre'
                    };
                    const prefix = nameMapping[ticketType] || ticketType;
                    const channelName = `${prefix}-${interaction.user.username}`.toLowerCase().replace(/[^a-z0-9-]/g, '');

                    // Permission Check
                    const ticketCategoryChannel = guild.channels.cache.get(targetCategoryId);
                    if (!ticketCategoryChannel) {
                        return interaction.reply({ content: '‚ùå Erreur: La cat√©gorie configur√©e est introuvable.', ephemeral: true });
                    }

                    const botPermissions = ticketCategoryChannel.permissionsFor(guild.members.me);
                    const requiredPerms = [
                        PermissionsBitField.Flags.ManageChannels,
                        PermissionsBitField.Flags.ManageRoles,
                        PermissionsBitField.Flags.ViewChannel,
                        PermissionsBitField.Flags.SendMessages,
                        PermissionsBitField.Flags.AttachFiles
                    ];

                    if (!botPermissions.has(requiredPerms)) {
                        const missing = requiredPerms.filter(p => !botPermissions.has(p)).map(p => {
                            const name = Object.keys(PermissionsBitField.Flags).find(key => PermissionsBitField.Flags[key] === p);
                            return name;
                        });

                        return interaction.reply({
                            content: `‚ùå **Permissions Manquantes**\n\nJe ne peux pas cr√©er le ticket car il me manque des permissions dans la cat√©gorie **${ticketCategoryChannel.name}**.\n\n‚ö†Ô∏è **Permissions manquantes :** ${missing.join(', ')}\n\nüëâ **Solution :** Accordez-moi ces permissions sur la cat√©gorie. Je dois avoir les permissions que je donne aux utilisateurs (ex: Attacher des fichiers).`,
                            ephemeral: true
                        });
                    }

                    try {
                        const ticketChannel = await guild.channels.create({
                            name: channelName,
                            type: ChannelType.GuildText,
                            parent: targetCategoryId,
                            topic: `Owner: ${interaction.user.tag} (${interaction.user.id}) | Type: ${ticketType}`
                        });

                        // Permissions post-creation to preserve category inheritance (avoid 50013)
                        await ticketChannel.permissionOverwrites.edit(interaction.user.id, {
                            ViewChannel: true,
                            SendMessages: true,
                            AttachFiles: true
                        });

                        await ticketChannel.permissionOverwrites.edit(interaction.guild.id, {
                            ViewChannel: false
                        });

                        if (cfg.supportRoles && Array.isArray(cfg.supportRoles)) {
                            for (const roleId of cfg.supportRoles) {
                                if (interaction.guild.roles.cache.has(roleId)) {
                                    await ticketChannel.permissionOverwrites.edit(roleId, {
                                        ViewChannel: true,
                                        SendMessages: true,
                                        AttachFiles: true
                                    }).catch(e => console.error(`Failed to add support role ${roleId}`, e));
                                }
                            }
                        }

                        const typeMap = {
                            'assistance': 'Assistance',
                            'report': 'Signalement',
                            'other': 'Autre'
                        };
                        const ticketTitle = typeMap[ticketType] || ticketType;

                        const embed = new EmbedBuilder()
                            .setTitle(`Ticket : ${ticketTitle}`)
                            .setDescription(`**Auteur:** ${interaction.user}\n**Raison:**\n${description}\n\n‚ö†Ô∏è **Important:**\n- Pr√©cisez votre demande avec le plus de d√©tails possible.\n- Ne spammez pas, une r√©ponse sera donn√©e en temps voulu.\n- Tout le monde a une vie, merci de patienter.\n- Les tickets sont trait√©s par ordre de priorit√©.`)
                            .setColor(0x00FF00)
                            .setTimestamp();

                        const row = new ActionRowBuilder()
                            .addComponents(
                                new ButtonBuilder().setCustomId('close_ticket').setLabel('Fermer le Ticket').setStyle(ButtonStyle.Danger).setEmoji('üîí'),
                                new ButtonBuilder().setCustomId('claim_ticket').setLabel('Prise en charge').setStyle(ButtonStyle.Secondary).setEmoji('üôã‚Äç‚ôÇÔ∏è')
                            );

                        let mentions = `${interaction.user}`;
                        if (cfg.supportRoles) cfg.supportRoles.forEach(id => mentions += ` <@&${id}>`);

                        await ticketChannel.send({ content: mentions, embeds: [embed], components: [row] });
                        await interaction.reply({ content: `‚úÖ Votre ticket a √©t√© cr√©√© : ${ticketChannel}`, ephemeral: true });

                    } catch (error) {
                        console.error(error);
                        await interaction.reply({ content: '‚ùå Erreur lors de la cr√©ation du ticket (V√©rifiez les permissions Cat√©gorie).', ephemeral: true });
                    }

                } else if (interaction.customId === 'close_reason_modal') {
                    // === ASSISTANCE: CLOSE TICKET ===
                    const cfg = config.assistance || {};
                    const reason = interaction.fields.getTextInputValue('close_reason');

                    await interaction.reply({ content: 'üîí Fermeture du ticket en cours...' });

                    const topic = interaction.channel.topic || "";
                    const ownerMatch = topic.match(/Owner: (.+?) \((\d+)\)/);
                    const claimerMatch = topic.match(/ClaimedBy: (.+?) \((\d+)\)/);

                    const owner = ownerMatch ? ownerMatch[1] : "Inconnu";
                    const ownerId = ownerMatch ? ownerMatch[2] : null;
                    const claimer = claimerMatch ? claimerMatch[1] : "Personne";
                    const closer = interaction.user.tag;
                    const closeTime = new Date().toLocaleString('fr-FR');

                    if (cfg.transcriptChannel) {
                        const messages = await interaction.channel.messages.fetch({ limit: 100 });
                        let transcriptContent = `--- TRANSCRIPT PRIME+ ASSISTANCE ---\n\n` +
                            `Ticket: ${interaction.channel.name}\n` +
                            `Type/Topic: ${topic}\n` +
                            `Propri√©taire: ${owner} (${ownerId})\n` +
                            `Pris en charge par: ${claimer}\n` +
                            `Ferm√© par: ${closer}\n` +
                            `Raison de fermeture: ${reason}\n` +
                            `Date: ${closeTime}\n\n` +
                            `--- MESSAGES ---\n`;

                        messages.reverse().forEach(msg => {
                            transcriptContent += `[${msg.createdAt.toLocaleString()}] ${msg.author.tag}: ${msg.content}\n`;
                        });

                        const transcriptPath = path.join(__dirname, `../transcripts/transcript-${interaction.channel.id}.txt`);
                        if (!fs.existsSync(path.dirname(transcriptPath))) fs.mkdirSync(path.dirname(transcriptPath), { recursive: true });
                        fs.writeFileSync(transcriptPath, transcriptContent);

                        const logChannel = interaction.guild.channels.cache.get(cfg.transcriptChannel);
                        if (logChannel) {
                            const requiredLogPerms = [
                                PermissionsBitField.Flags.ViewChannel,
                                PermissionsBitField.Flags.SendMessages,
                                PermissionsBitField.Flags.EmbedLinks,
                                PermissionsBitField.Flags.AttachFiles
                            ];
                            const botLogPerms = logChannel.permissionsFor(interaction.guild.members.me);

                            if (botLogPerms.has(requiredLogPerms)) {
                                const logEmbed = new EmbedBuilder()
                                    .setTitle('üìÑ Ticket Ferm√©')
                                    .addFields(
                                        { name: 'Propri√©taire', value: owner, inline: true },
                                        { name: 'Ferm√© par', value: closer, inline: true },
                                        { name: 'Pris en charge par', value: claimer, inline: true },
                                        { name: 'Raison', value: reason },
                                        { name: 'Date', value: closeTime }
                                    )
                                    .setColor(0xFF0000);

                                await logChannel.send({ embeds: [logEmbed], files: [transcriptPath] }).catch(err => console.error("Logs error:", err));
                            } else {
                                const missingLogPerms = requiredLogPerms.filter(p => !botLogPerms.has(p)).map(p => {
                                    return Object.keys(PermissionsBitField.Flags).find(key => PermissionsBitField.Flags[key] === p);
                                });
                                console.warn(`Missing permissions to send logs to channel ${logChannel.name}. Missing: ${missingLogPerms.join(', ')}`);
                            }
                        }
                    } // end if cfg.transcriptChannel

                    setTimeout(() => interaction.channel.delete().catch(() => { }), 3000);
                }
            }
        } catch (fatalError) {
            console.error("FATAL INTERACTION ERROR:", fatalError);
            if (!interaction.replied && !interaction.deferred) {
                try {
                    await interaction.reply({ content: '‚ùå Une erreur critique est survenue.', ephemeral: true });
                } catch (e) { }
            }
        }
    },
};
